1.1  

```scheme
10
12
8
3
6
19
#f
4
16
4
16
```

1.2

```scheme
(/ (+ 4
      5
      (- 2
         (- 3
            (+ 6
               (/ 4 5)))))
   3
   (- 6 2)
   (- 2 7))
```	

1.3

```scheme
(define (sub-two-larger-square a b c)
        (define (square x) (* x x))
        (define (max x y)
                (if (> x y) x y))
        (+ (square (max a b)) (square (max a c))))
```
1.4

```
如果b大于0，则计算a+b否则计算a-b	
```
1.5

```
如果为应用序，即：先求值，再应用
(test 0 (p))
(if (= 0 0) 0 (p)))
之后先求(= 0 0)为#t
因此返回0

如果为正则序，由外向内逐层展开
(test 0 (p))
(if (= 0 0) 0 (p)))
(if (= 0 0) 0 (p)))
...
会进入死循环
```

1.6

```scheme
根据12页某不起眼的注解说明：在if和cond之间另一个小差异是每个cond子句的<e>部分可以是一个表达式序列，如果对应的<p>确定为真，<e>中的表达式会顺序地求值，并将其最后一个表达式作为整个cond的值返回。而在if表达式里，<consequent>和<alternative>都只能是单个表达式。
由此可以推出，new-if在else情况下，会将后面的(sqrt-iter (imporve guess x) x)作为表达式序列顺序求值，求第一个sqrt-iter的值，之后再次到else情况下求sqrt-iter，无限迭代下去，最终耗尽内存。
```