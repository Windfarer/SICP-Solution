1.1  

```scheme
10
12
8
3
6
19
#f
4
16
4
16
```

1.2

```scheme
(/ (+ 4
      5
      (- 2
         (- 3
            (+ 6
               (/ 4 5)))))
   3
   (- 6 2)
   (- 2 7))
```	

1.3

```scheme
(define (sub-two-larger-square a b c)
        (define (square x) (* x x))
        (define (max x y)
                (if (> x y) x y))
        (+ (square (max a b)) (square (max a c))))
```
1.4

```
如果b大于0，则计算a+b否则计算a-b	
```
1.5

```
(define (p) (p))的特点是，运行(p)会进入死循环

如果为应用序，即：先遇到实际参数先求值
(test 0 (p))
首先0求值为0
(p)求值为(p)，反复求值
进入死循环

而如果为正则序，先展开（相当于做替换），有需要再求值，则
(test 0 (p))
题中说遇到if求值时，先对谓词部分求值，根据结果确定随后求值的子表达式部分。
(if (= 0 0) 0 (p)))
则先求(= 0 0)为#t
对0求值
返回0

(p)从始至终没有被求值过，因此不会陷入死循环
```

1.6

```
根据12页某不起眼的注解说明：在if和cond之间另一个小差异是,
每个cond子句的<e>部分可以是一个表达式序列，如果对应的<p>确定为真，
<e>中的表达式会顺序地求值，并将其最后一个表达式作为整个cond的值返回。
而在if表达式里，<consequent>和<alternative>都只能是单个表达式。

由此可以推出，new-if在else情况下，会将后面的
(sqrt-iter (imporve guess x) x)作为表达式序列顺序求值，
求第一个sqrt-iter的值，之后再次到else情况下求sqrt-iter，
无限迭代下去，最终耗尽内存。
```