1.1  

```scheme
10
12
8
3
6
19
#f
4
16
4
16
```

1.2

```scheme
(/ (+ 4
      5
      (- 2
         (- 3
            (+ 6
               (/ 4 5)))))
   3
   (- 6 2)
   (- 2 7))
```	

1.3

```scheme
(define (sub-two-larger-square a b c)
        (define (square x) (* x x))
        (define (max x y)
                (if (> x y) x y))
        (+ (square (max a b)) (square (max a c))))
```
1.4

```
如果b大于0，则计算a+b否则计算a-b	
```
1.5?

```
(define (p) (p))的特点是，运行(p)会进入死循环

如果为应用序，即：先遇到实际参数先求值
(test 0 (p))
首先0求值为0
(p)求值为(p)，反复求值
进入死循环

而如果为正则序，先展开（相当于做替换），有需要再求值，则
(test 0 (p))
题中说遇到if求值时，先对谓词部分求值，根据结果确定随后求值的子表达式部分。
(if (= 0 0) 0 (p)))
则先求(= 0 0)为#t
对0求值
返回0

(p)从始至终没有被求值过，因此不会陷入死循环
```

1.6*

```
if的<consequent>和<alternative>只会有一个被求值，
而new-if作为一个普通的函数，在实际参数被传入时，会对参数逐个求值，
于是就会对sqrt-iter求值（无论good-enough?的结果如何，都会求值），
形成无限递归，最终耗尽内存挂掉。
```