1.1  

```scheme
10
12
8
3
6
19
#f
4
16
4
16
```

1.2

```scheme
(/ (+ 4
      5
      (- 2
         (- 3
            (+ 6
               (/ 4 5)))))
   3
   (- 6 2)
   (- 2 7))
```	

1.3

```scheme
(define (sub-two-larger-square a b c)
        (define (square x) (* x x))
        (define (max x y)
                (if (> x y) x y))
        (+ (square (max a b)) (square (max a c))))
```
1.4

```scheme
如果b大于0，则计算a+b否则计算a-b	
```
1.5?

```scheme
(define (p) (p))的特点是，运行(p)会进入死循环

如果为应用序，即：先遇到实际参数先求值
(test 0 (p))
首先0求值为0
(p)求值为(p)，反复求值
进入死循环

而如果为正则序，先展开（相当于做替换），有需要再求值，则
(test 0 (p))
题中说遇到if求值时，先对谓词部分求值，根据结果确定随后求值的子表达式部分。
(if (= 0 0) 0 (p)))
则先求(= 0 0)为#t
对0求值
返回0

(p)从始至终没有被求值过，因此不会陷入死循环
```

1.6*

```scheme
if的<consequent>和<alternative>只会有一个被求值，
而new-if作为一个普通的函数，在实际参数被传入时，会对参数逐个求值，
于是就会对sqrt-iter求值（无论good-enough?的结果如何，都会求值），
形成无限递归，最终耗尽内存挂掉。
```

1.7*

```scheme
例如0.000001这个数字的平方根，应该是0.001，但求值求出的是
0.031260655525445276
过大的数字如
1000000000000000000000000000000000000000000000000000000000000000000000000
会导致程序死循环，因为小数精度不够比较两个很大数字之间的差。

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
 (/ (+ x y) 2))

(define (good-enough? guess x)
  (< (/ (abs (- (square guess) 
                x))
        guess)
     0.0001))

(define (square x)
  (* x x))

(define (sqrt x)
  (sqrt-iter 1.0 x))
```

1.8

```scheme
(define (cube-root x)
	(define (cube-root-iter guess x)
    (define (good-enough? guess x)
      (< (/ (abs (- (cube guess) 
                    x))
            guess)
         0.0001))
	  (define (cube x)
	    (* x x x))
	  (define (improve guess x)
	    (/ (+ (* 2 guess) 
	          (/ x 
	             (* guess guess))) 
	       3))
	  (if (good-enough? guess x)
	      guess
	      (cube-root-iter (improve guess x) x)))
  (cube-root-iter 1.0 x))
```

1.9

```scheme
第一种：
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

第二种：
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9

PS：我发现网上的题解写的答案是8，当时就吓尿了，以为自己竟然加法都不会算了，
然后发现题解的题目是算(+ 3 5)
这是翻译版教材故意加大难度吗= =
```

1.10*

```scheme
表达式的结果：
表达式1过程：
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 (A 0 (A 0 (A 1 7))))
(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
(A 0 (A 0 (A 0 (A 0 (A 0 32)))))
(A 0 (A 0 (A 0 (A 0 64))))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256))
(A 0 512)
1024

表达式2过程：
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
65536

表达式3过程：
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 4)
(A 1 16)
65536


(f n)  -> 2n
(g n)  -> 2^n
(h n)  -> 2^2^n
数学不好，累成狗，表示看了题解是直接通过运行代码观察规律的，
被自己蠢哭了
```

1.11

```scheme
递归
(define (f n)
  (cond ( (< n 3) n)
        (else (+ (f (- n 1))
                 (* 2 (f (- n 2)))
                 (* 3(f (- n 3)))))))
```

```scheme
迭代
(define (f-iter x y z n)
  (if (< n 4)
      (+ x (* 2 y) (* 3 z))
      (f-iter (+ x (* 2 y) (* 3 z)) x y (- n 1))))

(define (f x)
  (if (< x 3)
      x
      (f-iter 2 1 0 x)))

```

1.12

```scheme
(define (f m n)
  (cond ((or (= m 1) (= m 2)) 1)
        (else (if (or (= n 1) (= n m)) 
                  1
                  (+ (f (- m 1) (- n 1)) 
                     (f (- m 1) n))))))
```

1.13*

```scheme
证明题先哭一会
```

1.14*

```scheme
图太长了不知道怎么画上来

空间复杂度我猜是theta(n)
时间复杂度不会算= =
```

1.15

```scheme
a) 5次(话说rakect没trace的？)
b) 继续不会算
```

1.16

```scheme
迭代方式求幂计算,目前还有bug

#lang planet neil/sicp
(define (expt n b)
      (iter-expt n b 1 1))

(define (even? n)
  (= (remainder n 2) 0))

(define (change-status a b)
  (if (= a 1)
      (* b b)
      (* a a)))

(define (iter-expt n b a x)
  (cond ((= n 1) (* x a))
        ((even? n) (iter-expt (/ n 2) b (change-status a b) x))
        (else (iter-expt (- n 1) b a (* b x)))))

```
